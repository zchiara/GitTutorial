# 2. Le basi di Git

Questo è il capitolo fondamentale; vengono trattati tutti i comandi basilari che permettono di effettuare la stragrande maggioranza delle operazioni più comuni.

## 2.1 Creare un repository

Esistono due modi per creare un repository:

1. Inizializzare una repository Git all'interno di una cartella esistente 
2. Clonare una repository Git esistente da un altro server (volendo anche un'altra cartella nel nostro pc)

### 2.1.1 Inizializzare una repository in una cartella esistente

Per tener traccia di un progetto esistente, bisogna posizionarsi all'interno della directory del progetto con il terminale e digitare:

`git init`

Questo crea una nuova subdirectory chiamata `.git` che contiene tutti i file necessari per la repository.

A questo punto, a differenza di prima, è possibile iniziare a tracciare i file e fare un commit iniziare.

E' possibile iniziare a tracciare file mediante il comando

`git add <nome_file>`

e, dopo aver "aggiunto" tutti i file che si vogliono tracciare, effettuare il primo commit mediante il comando

`git commit -m"Commit iniziale"`

Vedremo il significato di questi comandi a breve. A questo punt abbiamo un repository Git con tracciati alcuni file ed un commit iniziale.

### 2.1.2 Clonare una repository esistente

Per ottenere una copia di una repository Git esistente, ad esempio di un progetto a cui si vuole contribuire, o ad esempio di una nostra stessa repo hostata su un server, il comando da utilizzare è

`git clone <url o path> <path in cui salvare la repo>`

Questo ci fa intuire che l'operazione che viene effettuata da Git è una vera e propria clonazione del repository, di tutta la sua storia e versioni precedenti del progetto.

Questo ci dimostra anche la solidità di Git, in quanto, nel caso in cui il disco del server si danneggiasse, sarebbe possibile copiare una copia di un qualsiasi client nuovamente sul server.

N.B. Qualora non si inserisse il path in cui salvare la repo, questa viene clonata all'interno di una cartella, nella directory corrente, avente lo stesso nome della repository.

## 2.2 Memorizzare cambiamenti in un repository

A questo punto, abbiamo una repository sul nostro pc; ora bisogna poter effettuare cambiamente ed effettuare commit delle istantanee (d'ora in avanti *snapshot*) del progetto, una volta effettuati i cambiamenti, caricandoli nel repository ogni volta che il progetto ha raggiunto uno stato che si vuole memorizzare.

E' importante ricordare che i file del progetto possono esistere in due stati: **tracked** e **untracked**.

1. **Tracked** sono i file che erano presenti nell'ultimo snapshot e possono essere:
  - **unmodified**
  - **modified**
  - **staged**
2. **Untracked** sono tutti gli altri file presenti nella directory del progetto che non sono presenti nell'ultimo snapshot o nella stagin area.

Subito dopo aver clonato una repository, tutti i file sono tracked e unmodified in quanto Git li ha appena clonati e questi non sono stati ancora modificati.

Appena viene modificato un file, Git se ne accorge in quanto diverso dall'ultimo commit; il file si può quindi aggiungere alla staging area per preparare queste modifiche ad essere inserite nel prossimo commit, si effettua poi il commit, ed il ciclo si ripete.

![Stati File](img/statoFile.png "Stati File")

### 2.2.1 Controllare lo stato dei file

Il comando più importante, utile a determinare quali file si trovano in quale stato è `git status`.

Questo comando ci da le seguenti informazioni:

- Su quale branch ci troviamo (vedremo più avanti questo concetto)
- Se ci sono e quali sono i file che sono stati modificati
- Se ci sono e quali sono i file untracked
- A che commit siamo rispetto al repository remoto

E' possibile anche utilizzare la sintassi

`git status -s` oppure `git status --short`

il quale restituisce un elenco di file con accanto un "codice" che può essere

- ?? che significa untracked
- A nuovi file inseriti nella staging area
- M modificato

ecc. (per altre info fare riferimento al manuale)

### 2.2.2 Tracciare nuovi file

Per iniziare a tracciare un file bisogna utilizzare il comando `git add <nome file o elenco di file>`.

Ora, `git status` ci dirà "changes to be committed" e ci mostrerà il file appena aggiunto.

In questo momento il file si trova nella `staging area` di cui abbiamo parlato nel capitolo 1.

### 2.2.3 File modificati

Per aggiungere i file modificati alla staging area bisogerà nuovamente usare `git add`.

Possiamo intuire come questo comando abbia più di un utilizzo:

1. Permette di iniziare a tracciare le modifiche su un file

2. Consente di aggiungere un file che si sta già tracciando alla staging area per prepararlo ad essere inserito nel prossimo commit.

Qualora un file già aggiunto alla staging area venisse modificato prima di effettuare il commit, questo per `git status` apparirà sia avente modifiche che saranno "committate", sia avente modifiche che non saranno "committate".

Ciò avviene in quanto prima di effettuare questa ultima modifica, avevamo memorizzato un suo snapshot nella staging area, rendendolo pronto per essere committato; in seguito le modifiche effettuate, non essendo state "aggiunte" (non è stato fatto `git add`) non saranno presenti nel nuovo commit.

### 2.2.4 Ignorare file

### 2.2.5 Differenze tra i file nella staging area e non nella staging area

### 2.2.6 Effettuare un commit

### 2.2.7 Rimuovere un file

### 2.2.8 Rinominare un file

---

Il materiale è redistribuito sotto licenza [Creative Commons, CC BY-NC-SA 3.0][licenza]

![Licenza CC BY-NC-SA 3.0](img/license.png "Licenza CC BY-NC-SA 3.0")

[licenza]: https://creativecommons.org/licenses/by-nc-sa/3.0/

---

[Indice][index] - [Capitolo Precedente][prev] - [Capitolo Successivo][next]

[index]: https://github.com/FraClem/GitTutorial/blob/master/Indice.md
[prev]: https://github.com/FraClem/GitTutorial/blob/master/1.%20Per%20iniziare.md
[next]: https://github.com/FraClem/GitTutorial/blob/master/3.%20Branching.md 

---
